<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <title>Minimalistischer Kalender 2026</title>
  <meta name="viewport" content="width=1284, initial-scale=1">
</head>

<body>
  <div class="calendar-container">
    <img id="calendar-img" width="1284" height="2778" alt="Kalender 2026" />
    <svg id="calendar-svg" width="1284" height="2778" viewBox="0 0 1284 2778" xmlns="http://www.w3.org/2000/svg"
      style="display:none;"></svg>
  </div>
  <script>
    // Calendar parameters
    // --- Configurable variables ---
    const months = ["Januar", "Februar", "MÃ¤rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"];
    const year = 2026;
    const today = new Date(); // Real time current date
    const svg = document.getElementById('calendar-svg');
    const width = 1284, height = 2778;
    // Colors
    const colorPast = '#bbb';
    const colorToday = '#ff1c12';
    const colorFuture = '#666';
    // Font (use web-safe for GitHub Pages)
    const fontFamily = 'Arial, Helvetica, sans-serif';
    const labelFont = '36px ' + fontFamily;
    // --- Layout variables ---
    const marginH = 0; // horizontal margin (very small)
    const gridTop = height * (2 / 3);
    const gridBottom = height * (1 / 5);
    const gridHeight = gridBottom - gridTop;
    const cols = 3, rows = 4;
    const monthW = (width - 2 * marginH) / cols;
    const monthH = gridHeight / rows - 15;
    const dotR = 13;
    const dotGap = dotR * 1.5;
    svg.innerHTML = '';

    // --- Parse URL for custom text ---
    function getCustomText() {
      const params = new URLSearchParams(window.location.search);
      return params.get('text') || '';
    }
    const customText = getCustomText();

    // --- Parse URL for event colors and events ---
    // Format: ?ci=Hex1-Hex2...&q=day_colorindex-day_colorindex-...
    function getEventColors() {
      const params = new URLSearchParams(window.location.search);
      const ci = params.get('ci');
      if (!ci) return [];
      return ci.split('-').map(hex => '#' + hex);
    }
    function getDayEvents() {
      const params = new URLSearchParams(window.location.search);
      const q = params.get('q');
      if (!q) return {};
      const map = {};
      q.split('-').forEach(pair => {
        // Match: day_colorindex or day_colorindexX
        const match = pair.match(/^(\d{1,3})_(\d{1,2})(X)?$/);
        if (match) {
          const dayNr = parseInt(match[1], 10);
          const colorIdx = parseInt(match[2], 10);
          const isDark = !!match[3];
          if (!map[dayNr]) map[dayNr] = [];
          map[dayNr].push({ colorIdx, isDark });
        }
      });
      return map;
    }
    const eventColors = getEventColors();
    const dayEvents = getDayEvents();

    // Helper: get day of year (1-based)
    function getDayOfYear(date) {
      const start = new Date(date.getFullYear(), 0, 0);
      const diff = date - start;
      const oneDay = 1000 * 60 * 60 * 24;
      return Math.floor(diff / oneDay);
    }

    function daysInMonth(m, y) {
      return new Date(y, m + 1, 0).getDate();
    }

    // Add SVG background rectangle
    const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bgRect.setAttribute('x', 0);
    bgRect.setAttribute('y', 0);
    bgRect.setAttribute('width', width);
    bgRect.setAttribute('height', height);
    bgRect.setAttribute('fill', '#222');
    svg.appendChild(bgRect);

    // Draw months
    let dayOfYearCounter = 1;
    for (let m = 0; m < 12; m++) {
      const row = Math.floor(m / cols);
      const col = m % cols;
      // Invert the row index so January is at the top and December at the bottom
      const invertedRow = rows - 1 - row;
      const x0 = marginH + col * monthW;
      const y0 = gridTop + invertedRow * monthH;
      // Month label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', x0 + monthW / 2);
      label.setAttribute('y', y0 + 40);
      label.setAttribute('text-anchor', 'middle');
      label.setAttribute('fill', colorPast);
      label.setAttribute('font-family', fontFamily);
      label.setAttribute('font-size', '36px');
      label.setAttribute('font-weight', 'bold');
      label.textContent = months[m];
      svg.appendChild(label);
      // Days grid
      const days = daysInMonth(m, year);
      const gridCols = 7;
      const startX = x0 + (monthW - (gridCols * dotR * 2 + (gridCols - 1) * dotGap)) / 2;
      const startY = y0 + 70;
      // Find the weekday of the 1st of the month (0=Sunday, 1=Monday, ... 6=Saturday)
      let firstDay = new Date(year, m, 1).getDay();
      // Adjust so Monday is column 0 (German/ISO week): 0=Monday, 6=Sunday
      firstDay = (firstDay + 6) % 7;
      for (let d = 1; d <= days; d++) {
        const dayDate = new Date(year, m, d);
        const todayDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        const dayIdx = d - 1;
        // Offset by firstDay so the first day lands in the correct column
        const colIdx = (dayIdx + firstDay) % gridCols;
        const rowIdx = Math.floor((dayIdx + firstDay) / gridCols);
        const cx = startX + colIdx * (dotR * 2 + dotGap) + dotR;
        const cy = startY + rowIdx * (dotR * 2 + dotGap) + dotR;
        // Check if this day is a Monday
        const isMonday = dayDate.getDay() === 1;
        // Determine segments for this day
        let segments = [];
        // Events for this day
        const events = dayEvents[dayOfYearCounter] || [];
        // If today, always include today color as a segment
        const isToday = dayDate.getTime() === todayDate.getTime();
        if (isToday) segments.push(colorToday);
        // Add event colors, supporting 'X' for dark variant
        events.forEach(ev => {
          if (eventColors[ev.colorIdx]) {
            if (ev.isDark) {
              // Convert hex to rgba with alpha for dark effect
              const hex = eventColors[ev.colorIdx].replace('#', '');
              const r = parseInt(hex.substring(0, 2), 16);
              const g = parseInt(hex.substring(2, 4), 16);
              const b = parseInt(hex.substring(4, 6), 16);
              segments.push(`rgba(${r},${g},${b},0.6)`); // 0.6 alpha for darker look
            } else {
              segments.push(eventColors[ev.colorIdx]);
            }
          }
        });
        // If no segments, use default color logic
        if (segments.length === 0) {
          let color = colorFuture;
          if (dayDate < todayDate) color = colorPast;
          if (isToday) color = colorToday;
          // Draw single color circle
          const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          dot.setAttribute('cx', cx);
          dot.setAttribute('cy', cy);
          dot.setAttribute('r', dotR);
          dot.setAttribute('fill', color);
          svg.appendChild(dot);
          // If Monday, add small number in background color
          if (isMonday) {
            const num = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            num.setAttribute('x', cx);
            num.setAttribute('y', cy + 5); // vertical centering tweak
            num.setAttribute('text-anchor', 'middle');
            num.setAttribute('fill', '#222');
            num.setAttribute('font-family', fontFamily);
            num.setAttribute('font-size', '18px');
            num.setAttribute('font-weight', 'bold');
            num.textContent = d;
            svg.appendChild(num);
          }
        } else if (segments.length === 1) {
          // Only one segment, draw as circle
          const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          dot.setAttribute('cx', cx);
          dot.setAttribute('cy', cy);
          dot.setAttribute('r', dotR);
          dot.setAttribute('fill', segments[0]);
          svg.appendChild(dot);
          // If Monday, add small number in background color
          if (isMonday) {
            const num = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            num.setAttribute('x', cx);
            num.setAttribute('y', cy + 5);
            num.setAttribute('text-anchor', 'middle');
            num.setAttribute('fill', '#FFF');
            num.setAttribute('font-family', fontFamily);
            num.setAttribute('font-size', '18px');
            num.setAttribute('font-weight', 'bold');
            num.textContent = d;
            svg.appendChild(num);
          }
        } else if (segments.length === 2) {
          // Two segments: split horizontally (top/bottom)
          let startAngle = 0;
          let endAngle = Math.PI;
          let x1 = cx + dotR * Math.cos(startAngle);
          let y1 = cy + dotR * Math.sin(startAngle);
          let x2 = cx + dotR * Math.cos(endAngle);
          let y2 = cy + dotR * Math.sin(endAngle);
          let pathData = [
            `M ${cx} ${cy}`,
            `L ${x1} ${y1}`,
            `A ${dotR} ${dotR} 0 0 1 ${x2} ${y2}`,
            'Z'
          ].join(' ');
          let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', pathData);
          path.setAttribute('fill', segments[0]);
          svg.appendChild(path);
          // Bottom half
          startAngle = Math.PI;
          endAngle = 2 * Math.PI;
          x1 = cx + dotR * Math.cos(startAngle);
          y1 = cy + dotR * Math.sin(startAngle);
          x2 = cx + dotR * Math.cos(endAngle);
          y2 = cy + dotR * Math.sin(endAngle);
          pathData = [
            `M ${cx} ${cy}`,
            `L ${x1} ${y1}`,
            `A ${dotR} ${dotR} 0 0 1 ${x2} ${y2}`,
            'Z'
          ].join(' ');
          path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', pathData);
          path.setAttribute('fill', segments[1]);
          svg.appendChild(path);
          // If Monday, add small number in background color
          if (isMonday) {
            const num = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            num.setAttribute('x', cx);
            num.setAttribute('y', cy + 5);
            num.setAttribute('text-anchor', 'middle');
            num.setAttribute('fill', '#222');
            num.setAttribute('font-family', fontFamily);
            num.setAttribute('font-size', '18px');
            num.setAttribute('font-weight', 'bold');
            num.textContent = d;
            svg.appendChild(num);
          }
        } else {
          // Multiple segments: draw as pie chart (default)
          const angleStep = 2 * Math.PI / segments.length;
          for (let i = 0; i < segments.length; i++) {
            const startAngle = i * angleStep - Math.PI / 2;
            const endAngle = startAngle + angleStep;
            const x1 = cx + dotR * Math.cos(startAngle);
            const y1 = cy + dotR * Math.sin(startAngle);
            const x2 = cx + dotR * Math.cos(endAngle);
            const y2 = cy + dotR * Math.sin(endAngle);
            const largeArcFlag = angleStep > Math.PI ? 1 : 0;
            const pathData = [
              `M ${cx} ${cy}`,
              `L ${x1} ${y1}`,
              `A ${dotR} ${dotR} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
              'Z'
            ].join(' ');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', segments[i]);
            svg.appendChild(path);
          }
          // If Monday, add small number in background color
          if (isMonday) {
            const num = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            num.setAttribute('x', cx);
            num.setAttribute('y', cy + 5);
            num.setAttribute('text-anchor', 'middle');
            num.setAttribute('fill', '#222');
            num.setAttribute('font-family', fontFamily);
            num.setAttribute('font-size', '18px');
            num.setAttribute('font-weight', 'bold');
            num.textContent = d;
            svg.appendChild(num);
          }
        }
        dayOfYearCounter++;
      }
    }

    // --- Draw custom text below all months if present ---
    if (customText) {
      // Calculate y position: below the last row of months
      const lastRowY = gridTop + (rows) * monthH;
      const textY = lastRowY + 60; // 60px below last row
      const textElem = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      textElem.setAttribute('x', width / 2);
      textElem.setAttribute('y', textY);
      textElem.setAttribute('text-anchor', 'middle');
      textElem.setAttribute('fill', '#fff');
      textElem.setAttribute('font-family', fontFamily);
      textElem.setAttribute('font-size', '40px');
      textElem.setAttribute('font-weight', 'bold');
      textElem.textContent = customText;
      svg.appendChild(textElem);
    }

    // Render SVG as image
    // Unicode-safe base64 encoding for SVG
    function base64EncodeUnicode(str) {
      try {
        // First we escape the string using encodeURIComponent to get the UTF-8 encoding of the characters,
        // then we convert the percent encodings into raw bytes, and finally btoa for base64.
        const encoded = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
          return String.fromCharCode('0x' + p1);
        });
        const b64 = btoa(encoded);
        //alert('base64EncodeUnicode success');
        return b64;
      } catch (e) {
        alert('base64EncodeUnicode error: ' + e);
        return '';
      }
    }

    function renderSVGToImage() {
      try {
        const img = document.getElementById('calendar-img');
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svg);
        const svgBase64 = 'data:image/svg+xml;base64,' + base64EncodeUnicode(svgString);
        img.src = svgBase64;
        img.alt = svgBase64;
      } catch (e) {
        alert('renderSVGToImage error: ' + e);
      }
    }
    renderSVGToImage();
  </script>
</body>

</html>
